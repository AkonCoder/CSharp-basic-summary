# Csharp-basic-summary
总结C#的一些基础知识，知其然，知其所以然。


C#基础总结（一）
-----
标签（空格分隔）： c#基础 变量交换 面向对象
#### C#的三大特性：
继承
封装
多态

#### C#的访问修饰符
private
*只能在当前类中可以访问*
internal
*在当前程序集中可以访问*
internal protected
*在当前程序集和继承类中可以访问*
protected
*在当前类中和继承类中国可以访问*
public
*可以公开访问*

>  **类的成员**默认的访问修饰符是private, 也就是类中的成员变量在声明的时候，可以不加访问修饰符，但默认的访问属性是private;
**类**的默认访问修饰符是internal，也就是砸当前程序集中都可以访问该类，类不加访问修饰符时，编辑器会默认添加internal为访问级别。需要注意的是类不可以声明为private、protected、internal protected，只能声明为public、internal；

####交换两个变量的方法
（1）中间变量法
这是做常用的方法，现在介绍一种异或运算方法，进行两个变量的交换的值。
>异或运算的规则是：
两个变量中有只且只有一个为真时才为真。
所以：
真^ 假= 真； 真^ 真= 假；假^ 假= 假；假^ 真= 真；

```
例如：a=10；b=12；
a的二进制表示为：1010 b的二进制为：1100
所以 a^ b = 0110
a = a^ b；
b = a^ b；
a = a^ b；
此时：a=12； b=10；
```

　>其他的方法：
　（1）先说一下我们经常用的那个方法，即借助一个中间变量。代码如下：
  
     int a, b, temp;
     a = 10;
     b = 5;
     temp = a;
     a = b;
     b = temp;
     
这种算法易于理解，特别适合帮助初学者了解计算机程序的特点，是赋值语句的经典应用。
所以咱们至少应该掌握这种算法。

（2）下面就讲一下怎么不用中间变量来实现两个值得交换。一共总结了三种算法。如下

#####第一种称为算术运算

简单来说就是通过普通的+和-运算来实现，代码如下：
```
1            int a, b;
2             a = 10;
3             b = 2;
4             a = b - a;//a=-8,b=10
5             b = b - a;//a=-8,b=10
6             a = b + a;//a=2,b=10 交换成功
```
这种方法表面看起来简单，但是却不容易想到，现在说一说它的原理：把a、b看做是数轴上的两点，围绕两点间的距离来进行计算。具体过程如下：

a=b-a;求出ab两点的距离，并将结果保存在a中；b=b-a;求出a到原点的距离，并将结果保存在b中；a=b+a;求出b到原点的距离，并将结果保存在a中。这样就交换了ab两个数的值。

#####第二种是位运算

通过异或运算来实现两个变量值的交换，这应该算是最神奇的算法了，现在揭晓一下代码吧。
>1            int a, b;
2             a = 20; b = 2;
3             a = a ^ b;//a=10100,b=0010,两者相异或的结果是10110,并保存在a中。
4             b = a ^ b;//a=10110,b=0010,两者相异或的结果是10100，并保存在b中，换成二进制是20
5             a = a ^ b;//a=10110,b=10100,两者相异或的结果是00010，保存在a中，换成十进制是2


---
### C#基础总结（二）

标签（空格分隔）： C#基础 继承的好处 构造函数

---
##### 继承的好处：
*代码重用*
*多态*

#####  构造函数
> 构造函数并不能继承，子类继承父类的时候，先调用父类的无参构造函数，如果父类没有无参构造函数，则会报错。反之如果要调用父类的构造函数，必须通过base关键字进行调用。

##### 使用this调用构造函数
（1）使用this调用本类的构造函数
（2）使用this、base调用类中的成员变量


##### 访问级别约束
（1）子类必须比父类的访问级别低

##### 多态的实现方式
（1）虚方法
（2）父类方法声明virtual，子类可以重写该方法。
（3）使用new关键字隐藏父类的方法，在使用sdk或者dll时，更新了基类的sdk代码，方法与子类中的方法重名了，可以使用new关键字隐藏父类的方法。

##### 静态成员、静态类
（1）静态类中的成员必须是静态成员。
（2）静态成员并不一定在静态类中。
（3）静态成员属于类的，不属于具体的对象。所以访问静态成员时，不能通过对象名来访问，只能通过类名来访问。
（4）工具类使用静态类

##### 静态构造函数的特点
（1）不能添加访问修饰符，默认为private
（2）静态构造函数无参数
（3）静态成员初次调用的时候，静态构造函数才被第一次调用
（4）静态构造函数只执行一次
 (5) 静态构造函数先执行，然后进行实例构造函数的执行。
 
 C#高效编程里说到,这样一段话:
创建某个类型的第一个实例时,所进行的操作顺序为:
1.静态变量设置为0
2.执行静态变量初始化器
3.执行基类的静态构造函数
4.执行静态构造函数
5.实例变量设置为0
6.执行衯变量初始化器
7.执行基类中合适的实例构造函数
8.执行实例构造函数


##### 类型转换
（1）强制转换 
（2）as 转换（转换失败不报异常，返回null，转换成功返回对象）


##### 实现多态的方式
（1）virtual方法
（2）abstract方法
（3）接口

##### 抽象方法与虚方法的不同

抽象
1.虚方法（virtual)有方法体，抽象方法(abstract)没有方法体【类似接口】

virtual void SayWord()
{
//代码
}
abstract void SayWord();
 2.虚方法（virtual)在派生类中可以不重写，抽象方法(abstract)派生类中必须重写【类似接口】
复制代码
abstract class Person
{
     abstract void SayName();
}
class Man:Person
{
     override void SayName()
     {
       //方法实体
      }
}
复制代码
 3.抽象方法(abstract)必须声明在抽象类中


下面给出实例代码：
复制代码
 class Program
    {
        static void Main(string[] args)
        {
            Cat cat = new Cat("小花","2");
            cat.Eat();
            //调用父类中的虚方法，如果派生类中重写则调用重写后的
            cat.ShowName();
            Console.ReadKey();
　　　　　　　//最后输出结果是:
　　　　　　　　猫吃东西
　　　　　　　　我的名字是小花，今年2岁了　
        }
    }

    public abstract class Animal
    {
        protected string name;

        public string Name
        {
            get { return name; }
            set { name = value; }
        }
        protected string age;

        public string Age
        {
            get { return age; }
            set { age = value; }
        }
        
        /// <summary>
        /// 虚方法
        /// </summary>
        public virtual void ShowName()
        {
            Console.WriteLine("我的名字是{0}，今年{1}岁了", this.name,this.age);
        }
        /// <summary>
        /// 抽象方法
        /// </summary>
        public abstract void Eat();


    }

    public class Cat : Animal
    {
        /// <summary>
        /// 派生类必须重写父类中的抽象方法，否则会报错
        /// </summary>
        public override void Eat()
        {
            Console.WriteLine("猫吃东西");
        }

        public Cat(string name, string age)
        {
            this.name = name;
            this.age = age;
        }
    }

   

